---
title: 关于贪心算法的一点理解
date: 2022-10-17 13:00:03
auther: WJS
top: false
mathjax: true
cover: false
toc: true
comments: false
summary:
tags:
  - algorithm
categories:
  - algorithm
---

# 1. 贪心的基本性质

## 1.1 最优子结构

简单来说，后面的状态可以由前面的状态推导得到。即最终的最优解必然包含已经得到的局部最优解。

我对该性质的理解是，子问题与原问题应当具有同样的结构，也就是二者本质上是一个问题。

## 1.2 贪心选择性

这是贪心算法和动态规划算法的一个区别，也就是贪心算法足够的贪婪，使得它在解决问题的过程中只考虑当前情况下的最优解而不去考虑对全局的影响。而动态规划则需要存储已经经过的子问题的状态，即需要在已经有的子问题间做出选择，再根据状态转移方程（状态转移需要动态规划满足最优子结构的性质，这样才能从局部推全局）得出最优解。

所以我们可以得出，贪心问题一定可以用动态规划的方法去做，反之则不成立。故一般而言，贪心算法的复杂度要比动态规划低，但动态规划适用的范围更广，贪心则对问题的要求很苛刻。

### 引申：无后效性

由贪心算法的贪心选择性可以得出，贪心问题应当具备的特点是无后效性，即在解决局部最优的问题后就不用再考虑已经解决的问题对后面算法的影响。

# 2. 题目

## 2.1 均分纸牌问题（NOIP2002 提高级）

[**题目链接**](https://www.luogu.com.cn/problem/P1031)

## 2.2 均分石子问题（？？？）

**没有链接**

# 3. 题目分析

## 3.1 为什么想到“均分纸牌”

假设我们已经知道对于均分纸牌问题，需要用到贪心的算法来解答。那么这个问题和均分纸牌的区别就变成了均分纸牌处理的是一条链，它的起点和终点是固定的，而均分石子则变成了一个环，没有起点和终点。所以可以得出解决均分石子问题的一个思路：即枚举每一堆石子，将其作为贪心算法的起点，那么子问题就变成了均分纸牌（细节上有区别，忽略），最后在n个均分纸牌问题中取最优的答案即可。

## 3.2 对子问题的分析

### 3.2.1 子问题描述

子问题应该是这样的：

>有N堆纸牌，编号分别为 1,2,…,N。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若干张纸牌，然后移动。
>
>移牌规则为：在编号为 1 堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 N 的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。
>
>现在要求找出一种移动方法，**使移动纸牌的总张数最少**，求这个最少的张数。

### 3.2.2 子问题分析

设$x_{1},x_{2},\cdots,x_{n}$分别为这$n$堆纸牌的初始张数，$avg = \frac{\sum_{i=1}^{n}{x_{i}}}{n}$ 即最终需要的每堆纸牌的张数。
$$
def : f(x_{1},x_{2},\cdots,x_{r})=将x_{1},x_{2},\cdots,x_{r}均分所需的最小移动纸牌数
$$

##### 可以得到状态转移方程：

$$
f(x_{1},x_{2},\cdots,x_{r})=
\left\lbrace \begin{matrix} 
  f(x_{2}+x_{1}-avg,x_{3},\cdots,x_{r})+\left|x_{1}-avg\right| \qquad (x_{1} \neq avg )\\\\  
  f(x_{2},x_{3},\cdots,x_{r}) \qquad (x_{1}=avg)
\end{matrix}\right.
$$

##### 解释：

对于当前状态$x_{1},x_{2},\cdots,x_{r}$ , **$x_{1}$必然最终会变成$avg$**，所以我们不妨先考虑$x_{1}$。

对于$x_{1}$搬运所付出的代价为$\left|x_{1}-avg\right|\times 搬运距离$（题目只允许相邻的牌堆间搬运，若从不相邻的堆搬运需要多搬运成倍的纸牌数），由于要求最小的代价，最优结果为从相邻的牌堆搬运或搬运给相邻的牌堆，搬运个数为$\left|x_{1}-avg\right|$，搬运后相邻牌堆更新为$x_{2}+x_{1}-avg$（这里存在一步简化，原则上我们只能从数量多的牌堆搬向数量少的牌堆，但由于我们顺序是固定的，所以**允许搬运负数张牌**），若$x_{1}=avg$则不需要搬运，个数为0。

##### 证明：

我们为什么可以这么做？

1. 最优子结构

   容易看出$f((x_{2}+x{1}-avg),x_{3},\cdots,x_{r})$和原问题结构是一致的，牌堆数目的减少并不影响求解方式。且我们可以根据状态转移方程从子问题的答案推导到原问题的答案。

   **注：**这里体现出动态规划和贪心的区别，动态规划的转移方程一般是从少往多推，即从简单到复杂。而贪心由于可以只考虑当前状况最优而无后效性，所以转移方程是从复杂到简单的，我们认为每一步都存在一种**策略**使我们可以把问题简化。

2. 无后效性

   当牌堆数从$r$减少到$r-1$时，对于后续的每一步操作，如果经过$x_{1}$都必然会增加成本（这里“经过”是指先搬到1上再挪回去，显然这种操作属于没事找事）。因为我们求的是最小值，且$x_{1}$已经平均，后面就可以完全不考虑$x_{1}$的影响，所以这一步简化操作无后效性。

至此，我们证明了原问题**满足贪心的所有条件**。

## 3.3 代码实现

python version:

```python
n = int(input())
a = [int(x) for x in input().split()]
avg = sum(a)//n
ans = 9999999
for i in range(n): # 枚举起点位置
    # 由于python固有的浅/深拷贝的恶心特性，需要加list()函数
    b = list(a)
    tmp = 0
    for j in range(i,i+n-1): # 从起点开始一步步简化
        tmp+= abs(b[j%n]-avg)
        b[(j+1)%n]+=b[j%n]-avg
    ans = min(ans,tmp) # 更新最小值
print(ans)
```

C version:
```c
#include <stdio.h>
#include <stdlib.h> //使用绝对值函数
#include <string.h> //memcpy，当然可以用for循环
int main()
{
    int n,avg,ans=9999999,sum=0;
    int a[1005],b[1005];
    scanf("%d",&n);
    for(int i=0;i<n;i++){	//从0开始方便后边取模
        scanf("%d",&a[i]);
        sum+=a[i];
    }
    avg = sum/n;
    for(int i=0;i<n;i++){
        memcpy(b,a,sizeof(a));
        int tmp = 0;
        for(int j=i;j<i+n-1;j++){
            /* 最后一个应该是i+n-1，但因为倒数第二个变成avg后
            最后一个必然也是avg，所以不考虑，这样也避免了数组越界 */
            tmp+= abs(b[j%n]-avg);
        	b[(j+1)%n]+=b[j%n]-avg;
        }
        ans = ans<tmp ? ans:tmp;  //C连个min函数都没有
    }
    printf("%d\n",ans);
}
```

